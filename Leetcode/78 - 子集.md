## 1 题目

https://leetcode-cn.com/problems/subsets/

## 2 题意

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:
```
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```



## 3 解题思路

>  author's blog == http://www.cnblogs.com/toulanboy/

### （1）子集的概念
子集，简单来说，就是将原集合的一部分元素抽出来形成的新集合。子集包含的元素个数可以是`0~n`。
> n: 原集合的长度

### （2）如何看待子集的形成
由于子集是原集合的一部分元素，那么对于每一个原集合的元素，都有可能被抽出或者不被抽出。
所以，我们可以给每一个原集合的元素用一个`bit`来标记其是否被抽出到新集合。

-	0代表没被抽出（没被选中）
-	1代表被抽出（被选中）

那么，若原集合有n个元素，由于每个元素都有选或不选两种可能，所以从排列组合的角度出发，原集合有`2^n`个子集。

### （3）举例学习

那么对于题目的样例`{1, 2, 3}`

从排列组合的角度来看，其一共有`3`个元素，每个元素都有选或不选的可能性，故共有`2^3`，即`8`个子集。

其子集和二进制的关系如下表

| 子集      | 二进制（为方便理解，部分有注释） | 十进制 |
| --------- | :------------------------------: | :----: |
| []        |         000（3个都不选）         |   0    |
| [3]       |         001（只选第3个）         |   1    |
| [2]       |         010（只选第2个）         |   2    |
| [2, 3]    |        011（选第2、第3）         |   3    |
| [1]       |               100                |   4    |
| [1, 3]    |               101                |   5    |
| [1, 2]    |               110                |   6    |
| [1, 2, 3] |               111                |   7    |

通过分析这个例子，我们可以发现一个特性：

**枚举子集的过程，实际上枚举二进制从`000`加到`111`的过程，也就是从`0`加到`7`的过程。**

> 该特性也可以从组合数学的角度出发分析：子集的每个元素都是选或不选，所以若原集合有n个元素，那么n个bit组成的二进制产生的所有情况都会被枚举到。换算成十进制的角度，就是枚举了0到2^n的过程。

### （4）重要结论

- 子集的枚举（以原集合只有3个元素为例子），实际上是枚举每一个元素的选或不选，等同于枚举3个bit组成的二进制的所有情况。而这个所有情况，可以通过枚举从`000`加到`111`实现。
- 000加到111的过程，可以是简单的二进制的加法。也可以是换算成`10进制`进行加法。

> 官方题解是基于十进制加法实现的，我的代码是基于二进制加法实现的，好处是二进制加法可以处理元素个数大于64的情况。

### （5）知识补充

这里主要是谈谈二进制的加法。

最直接是方式是 从个位开始加，然后不断进位，但是每次加法都需要遍历整个数组。

但实际上，通过观察二进制的加法过程，有一个更好的方法：

**具体方案：对于一个二进制，当需要进行加1时，只需从右往左找到第1个0，将这个0变为1，将这个0后面的1变为0。**




## 4 代码实现

```c++
//author's blog == http://www.cnblogs.com/toulanboy/
class Solution {
public:
  //add_one() : 对二进制进行加1
  //对于一个二进制，当需要进行加1时，只需从右往左找到第1个0，将这个0变为1，将这个0后面的1变为0。
    void add_one(int * binary, int n){
        for(int i=n-1; i>=0; i--){
            if(binary[i] == 0){
                binary[i] = 1;
                break;
            }
            else{
                binary[i] = 0;
            }
        }
    }
    vector<vector<int>> subsets(vector<int>& nums) {
        int n = nums.size();
        //创建长度为nums.size()，用来表示原集合的n个元素的选择情况。（思路中涉及到的二进制数组）
        int binary[n];
        memset(binary, 0, sizeof(binary));
        
        int times = pow(2, n);
        vector<vector<int>> ans;//存储所有子集
        vector<int> sub_set; //存储一个子集
        while(times--){//一共有2^n个子集
            sub_set.clear();
            for(int i=0; i<n; ++i){//枚举选择情况
                if(binary[i] == 1){
                    sub_set.push_back(nums[i]);
                }
            }
            ans.push_back(sub_set);
            //让二进制从0000累加到1111
            //十进制的角度：从0加到2^n-1
            add_one(binary, n);//二进制加1
        }
        return ans;
    }
};
```



